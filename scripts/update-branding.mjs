#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read branding configuration
const brandingPath = path.join(process.cwd(), 'src/config/branding.json');
const branding = JSON.parse(fs.readFileSync(brandingPath, 'utf8'));

// Generate CSS variables for globals.css
function generateCSSVariables() {
  const { colors } = branding;
  
  // Convert hex to HSL components for CSS variables
  /**
   * @param {string} hex - Hex color value
   * @returns {{h: number, s: number, l: number}}
   */
  function hexToHSL(hex) {
    const matches = hex.match(/\w\w/g);
    if (!matches) {
      throw new Error(`Invalid hex color: ${hex}`);
    }
    
    const rgb = matches.map((x) => parseInt(x, 16));
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (max + min) / 2;
    
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      
      switch (max) {
        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
        case g: h = ((b - r) / d + 2) / 6; break;
        case b: h = ((r - g) / d + 4) / 6; break;
      }
    }
    
    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      l: Math.round(l * 100)
    };
  }
  
  const primaryHSL = hexToHSL(colors.primary.hex);
  const secondaryHSL = hexToHSL(colors.secondary.hex);
  
  return `/* Updated by update-branding.mjs - DO NOT EDIT MANUALLY */
:root {
  /* Primary Color (${colors.primary.name}) */
  --primary: ${primaryHSL.h} ${primaryHSL.s}% ${primaryHSL.l}%;
  --primary-foreground: 0 0% 100%;
  
  /* Secondary Color (${colors.secondary.name}) */
  --secondary: ${secondaryHSL.h} ${secondaryHSL.s}% ${secondaryHSL.l}%;
  --secondary-foreground: 0 0% 100%;
  
  /* Brand Colors */
  --brand-primary: ${colors.primary.hex};
  --brand-secondary: ${colors.secondary.hex};
  --brand-accent: ${colors.accent.hex};
  
  /* Other theme variables remain unchanged */
}`;
}

// Update globals.css
function updateGlobalCSS() {
  const globalsPath = path.join(process.cwd(), 'src/styles/globals.css');
  let content = fs.readFileSync(globalsPath, 'utf8');
  
  // Find and replace the :root section
  const rootRegex = /:root\s*{[^}]*}/;
  const newRootVars = generateCSSVariables();
  
  if (rootRegex.test(content)) {
    content = content.replace(rootRegex, newRootVars);
  } else {
    // If no :root found, add it after @tailwind directives
    content = content.replace(
      /(@tailwind utilities;)/,
      `$1\n\n${newRootVars}`
    );
  }
  
  // Update font imports
  const fontImports = [
    branding.fonts.sans.import,
    branding.fonts.serif.import
  ].join('\n');
  
  // Replace or add font imports at the beginning
  if (content.includes('@import url')) {
    content = content.replace(/@import url[^;]+;/g, '');
  }
  content = fontImports + '\n\n' + content;
  
  fs.writeFileSync(globalsPath, content);
  console.log('‚úÖ Updated globals.css');
}

// Generate Tailwind config extension
function generateTailwindExtension() {
  const { colors, fonts, radius, shadows } = branding;
  
  return `// Generated by update-branding.mjs
export const brandingExtensions = {
  colors: {
    primary: {
      DEFAULT: '${colors.primary.hex}',
      ...${JSON.stringify(colors.primary.tailwind, null, 6)}
    },
    secondary: {
      DEFAULT: '${colors.secondary.hex}',
      ...${JSON.stringify(colors.secondary.tailwind, null, 6)}
    },
    brand: {
      primary: '${colors.primary.hex}',
      secondary: '${colors.secondary.hex}',
      accent: '${colors.accent.hex}',
    }
  },
  fontFamily: {
    sans: ${JSON.stringify(fonts.sans.family.split(',').map((f) => f.trim()))},
    serif: ${JSON.stringify(fonts.serif.family.split(',').map((f) => f.trim()))},
    playfair: ['Playfair Display', 'serif'],
  },
  borderRadius: ${JSON.stringify(radius, null, 4)},
  boxShadow: ${JSON.stringify(shadows, null, 4)}
};`;
}

// Update Tailwind config
function updateTailwindConfig() {
  const extension = generateTailwindExtension();
  const extensionPath = path.join(process.cwd(), 'src/styles/branding-extensions.js');
  
  fs.writeFileSync(extensionPath, extension);
  console.log('‚úÖ Generated branding-extensions.js');
  
  // Note: The actual tailwind.config.js would need to import this file
  console.log(`
üìù Remember to update your tailwind.config.js to include:

import { brandingExtensions } from './src/styles/branding-extensions.js';

And merge brandingExtensions into your theme.extend section.
`);
}

// Main execution
function main() {
  console.log('üé® Updating branding...\n');
  
  try {
    updateGlobalCSS();
    updateTailwindConfig();
    
    console.log('\n‚ú® Branding update complete!');
    console.log('\nüîÑ Please restart your development server to see the changes.');
  } catch (error) {
    console.error('‚ùå Error updating branding:', error);
    process.exit(1);
  }
}

main();